{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"emacs-ng # A new approach to Emacs - Including TypeScript, Threading, Async I/O, and WebRender. homepage \u2022 features \u2022 getting started \u2022 using deno \u2022 FAQ Overview # emacs-ng is based off of the native-comp branch of emacs, and regularly merges in the latest from that branch. The last merged commit is 978afd788f by Andrea Corallo (Thu Apr 1 2021). Motivation # The goal of this fork is to explore new development approaches. To accomplish this, we aim to maintain an inclusive and innovative environment. The project is not about replacing elisp with a more popular language like Javascript. We just want to make emacs more approachable for people who don't like lisp as much as we do. Contributions are welcome from anyone and we are always happy to invite new people to the project. We are open towards interesting ideas to make emacs better. Our only request is that you open an issue before starting work and be willing to take feedback from the core contributors. Why Emacs-ng # Emacs-ng is an additive native layer over emacs, bringing features like Deno's Javascript and Async I/O environment, Mozilla's Webrender (experimental opt-in feature), and other features in development. emacs-ng's approach is to utilize multiple new development approaches and tools to bring Emacs to the next level. emacs-ng is maintained by a team that loves Emacs and everything it stands for - being totally introspectable, with a fully customizable and free development environment. We want Emacs to be a editor 40+ years from now that has the flexibility and design to keep up with progressive technology. Why JavaScript # One of emacs-ng's primary features is integrating the Deno Runtime , which allows execution of JavaScript and Typescript within Emacs. The details of that feature are listed below, however many users would ask themselves WHY JAVASCRIPT? JavaScript is an extremely dynamic language that allows for a user to inspect and control their scripting environment. The key to note is that bringing in Deno isn't JUST JavaScript - it's an ecosystem of powerful tools and approaches that Emacs just doesn't have currently. TypeScript offers an extremely flexible typing system, that allows to user to have compile time control of their scripting, with the flexibility of types \"getting out of the way\" when not needed. Deno uses Google's v8 JavaScript engine, which features an extremely powerful JIT and world-class garbage collector. Usage of modern Async I/O utilizing Rust's Tokio library. Emacs-ng has WebWorker support, meaning that multiple JavaScript engines can be running in parallel within the editor. The only restriction is that only the 'main' JS Engine can directly call lisp functions. Emacs-ng also has WebAssembly support - compile your C module as WebAsm and distribute it to the world. Don't worry about packaging shared libraries or changing module interfaces, everything can be handled and customized by you the user, at the scripting layer. No need to be dependent on native implementation details. Performance # v8's world-class JIT offers the potential for large performance gains. Async I/O from Deno, WebWorkers, and WebAsm, gives you the tools to make Emacs a smoother and faster experience without having to install additional tools to launch as background processes or worry about shared library versions. Contributing # Contributions are welcome. We try to maintain a list of \"new contributor\" friendly issues tagged with \"good first issue\".","title":"Home"},{"location":"#emacs-ng","text":"A new approach to Emacs - Including TypeScript, Threading, Async I/O, and WebRender. homepage \u2022 features \u2022 getting started \u2022 using deno \u2022 FAQ","title":"emacs-ng"},{"location":"#overview","text":"emacs-ng is based off of the native-comp branch of emacs, and regularly merges in the latest from that branch. The last merged commit is 978afd788f by Andrea Corallo (Thu Apr 1 2021).","title":"Overview"},{"location":"#motivation","text":"The goal of this fork is to explore new development approaches. To accomplish this, we aim to maintain an inclusive and innovative environment. The project is not about replacing elisp with a more popular language like Javascript. We just want to make emacs more approachable for people who don't like lisp as much as we do. Contributions are welcome from anyone and we are always happy to invite new people to the project. We are open towards interesting ideas to make emacs better. Our only request is that you open an issue before starting work and be willing to take feedback from the core contributors.","title":"Motivation"},{"location":"#why-emacs-ng","text":"Emacs-ng is an additive native layer over emacs, bringing features like Deno's Javascript and Async I/O environment, Mozilla's Webrender (experimental opt-in feature), and other features in development. emacs-ng's approach is to utilize multiple new development approaches and tools to bring Emacs to the next level. emacs-ng is maintained by a team that loves Emacs and everything it stands for - being totally introspectable, with a fully customizable and free development environment. We want Emacs to be a editor 40+ years from now that has the flexibility and design to keep up with progressive technology.","title":"Why Emacs-ng"},{"location":"#why-javascript","text":"One of emacs-ng's primary features is integrating the Deno Runtime , which allows execution of JavaScript and Typescript within Emacs. The details of that feature are listed below, however many users would ask themselves WHY JAVASCRIPT? JavaScript is an extremely dynamic language that allows for a user to inspect and control their scripting environment. The key to note is that bringing in Deno isn't JUST JavaScript - it's an ecosystem of powerful tools and approaches that Emacs just doesn't have currently. TypeScript offers an extremely flexible typing system, that allows to user to have compile time control of their scripting, with the flexibility of types \"getting out of the way\" when not needed. Deno uses Google's v8 JavaScript engine, which features an extremely powerful JIT and world-class garbage collector. Usage of modern Async I/O utilizing Rust's Tokio library. Emacs-ng has WebWorker support, meaning that multiple JavaScript engines can be running in parallel within the editor. The only restriction is that only the 'main' JS Engine can directly call lisp functions. Emacs-ng also has WebAssembly support - compile your C module as WebAsm and distribute it to the world. Don't worry about packaging shared libraries or changing module interfaces, everything can be handled and customized by you the user, at the scripting layer. No need to be dependent on native implementation details.","title":"Why JavaScript"},{"location":"#performance","text":"v8's world-class JIT offers the potential for large performance gains. Async I/O from Deno, WebWorkers, and WebAsm, gives you the tools to make Emacs a smoother and faster experience without having to install additional tools to launch as background processes or worry about shared library versions.","title":"Performance"},{"location":"#contributing","text":"Contributions are welcome. We try to maintain a list of \"new contributor\" friendly issues tagged with \"good first issue\".","title":"Contributing"},{"location":"adv-features/","text":"Advanced Features # This section assumes you have completed \"Getting Started\" and \"Using Deno\" and have a basic familiarization with the elisp JavaScript API. WebWorkers # One of the big draws of emacs-ng is parallel scripting. You may or may not be familiar with the fact that vanilla emacs had lisp threads that you could create via (make-thread FUNC) . Lisp threads were concurrent, but not parallel. In addition to that limitation, lisp threads that were not the 'main thread' would only execute at specific times during emacs event loop. WebWorkers give you parallelism. Under the hood, they are spinning up a Rust std::thread (in C terms, this is analogous to a pthread). Due to this, there is a limited interface to exchange data between threads. Building up the WebWorker # We will start by creating the JavaScript our WebWorker will execute. Create a file named \"web-worker.js\" and insert the following: self . onmessage = ( input ) => { let { message } = input . data ; message += \" And My Axe \" ; self . postMessage ({ message }); self . close (); }; WebWorkers communicate via two special functions, postMessage and onmessage. onmessage will be called once our parent thread sends us a message, while we can use postMessage to send data back to the main thread. This example is appending a string to its input and handing that back to the main thread. We also called the close function, meaning that this WebWorker is \"one and done\", and will shut down once it has performed this operation a single time. If we did not call close, the worker would stay alive and await additional messages. Using our WebWorker # Create a new file with the following code: declare var lisp : any ; const worker = new Worker ( new URL ( \"web-worker.js\" , import . meta . url ). href , { type : \"module\" , deno : true , }); worker . onmessage = ( output ) => { const { message } = output . data ; // This is safe because our callback is back // on the main thread. lisp . print ( message ); } worker . postMessage ({ message : \"You have my sword .... \" }); This code spins up our WebWorker and passes it a message. Running this code with eval-ts-buffer should print a reference to a cool little obscure movie in your minibuffer. Using Deno with WebWorkers # WebWorkers do not have access to elisp functions - you will notice that if you attempt to use the lisp object you will get an error that it is not defined. However, WebWorkers do have full access to Deno. The recommended usage for WebWorkers is to Identify the slow or blocking portion of your existing or new elisp code Write your webworker to perform the operation and data manipulation and translate the results to a format that elisp will be able to use. I.e. if you want to walk a directory and return all files ending in \"foo\", perform that logic and construct the array on your WebWorker, and send that array to your main thread via sendMessage. Once your mainThread receives that information, you can call your elisp code to display it. It's recommended to avoid WebWorkers for pure I/O or subprocess operations. Instead, use Deno's built in async I/O capabilities outlined in their documentation . You should use WebWorkers when you have significant calculation or operation to perform on the returned data. An example would be: Don't use a webworker to just run git status . You may want to use a WebWorker if you are running git status, opening each file, and performing complex logic on each line of the file, and then returning a list of strings back to lisp for display. You can see their example for spawning a subprocess to see what the platform is capable of. This can allow for things normally handled by tramp -> you could ssh into a box, get a list of files, and then actually perform scripting logic on that result prior to passing it back to lisp for display. Current elisp can handle about half of that, however once ssh, or whatever process returns those results, any logic on the subprocesses output will be blocking the editor. You can also reference this module as another example.","title":"Advanced features"},{"location":"adv-features/#advanced-features","text":"This section assumes you have completed \"Getting Started\" and \"Using Deno\" and have a basic familiarization with the elisp JavaScript API.","title":"Advanced Features"},{"location":"adv-features/#webworkers","text":"One of the big draws of emacs-ng is parallel scripting. You may or may not be familiar with the fact that vanilla emacs had lisp threads that you could create via (make-thread FUNC) . Lisp threads were concurrent, but not parallel. In addition to that limitation, lisp threads that were not the 'main thread' would only execute at specific times during emacs event loop. WebWorkers give you parallelism. Under the hood, they are spinning up a Rust std::thread (in C terms, this is analogous to a pthread). Due to this, there is a limited interface to exchange data between threads.","title":"WebWorkers"},{"location":"adv-features/#building-up-the-webworker","text":"We will start by creating the JavaScript our WebWorker will execute. Create a file named \"web-worker.js\" and insert the following: self . onmessage = ( input ) => { let { message } = input . data ; message += \" And My Axe \" ; self . postMessage ({ message }); self . close (); }; WebWorkers communicate via two special functions, postMessage and onmessage. onmessage will be called once our parent thread sends us a message, while we can use postMessage to send data back to the main thread. This example is appending a string to its input and handing that back to the main thread. We also called the close function, meaning that this WebWorker is \"one and done\", and will shut down once it has performed this operation a single time. If we did not call close, the worker would stay alive and await additional messages.","title":"Building up the WebWorker"},{"location":"adv-features/#using-our-webworker","text":"Create a new file with the following code: declare var lisp : any ; const worker = new Worker ( new URL ( \"web-worker.js\" , import . meta . url ). href , { type : \"module\" , deno : true , }); worker . onmessage = ( output ) => { const { message } = output . data ; // This is safe because our callback is back // on the main thread. lisp . print ( message ); } worker . postMessage ({ message : \"You have my sword .... \" }); This code spins up our WebWorker and passes it a message. Running this code with eval-ts-buffer should print a reference to a cool little obscure movie in your minibuffer.","title":"Using our WebWorker"},{"location":"adv-features/#using-deno-with-webworkers","text":"WebWorkers do not have access to elisp functions - you will notice that if you attempt to use the lisp object you will get an error that it is not defined. However, WebWorkers do have full access to Deno. The recommended usage for WebWorkers is to Identify the slow or blocking portion of your existing or new elisp code Write your webworker to perform the operation and data manipulation and translate the results to a format that elisp will be able to use. I.e. if you want to walk a directory and return all files ending in \"foo\", perform that logic and construct the array on your WebWorker, and send that array to your main thread via sendMessage. Once your mainThread receives that information, you can call your elisp code to display it. It's recommended to avoid WebWorkers for pure I/O or subprocess operations. Instead, use Deno's built in async I/O capabilities outlined in their documentation . You should use WebWorkers when you have significant calculation or operation to perform on the returned data. An example would be: Don't use a webworker to just run git status . You may want to use a WebWorker if you are running git status, opening each file, and performing complex logic on each line of the file, and then returning a list of strings back to lisp for display. You can see their example for spawning a subprocess to see what the platform is capable of. This can allow for things normally handled by tramp -> you could ssh into a box, get a list of files, and then actually perform scripting logic on that result prior to passing it back to lisp for display. Current elisp can handle about half of that, however once ssh, or whatever process returns those results, any logic on the subprocesses output will be blocking the editor. You can also reference this module as another example.","title":"Using Deno with WebWorkers"},{"location":"faq/","text":"JavaScript FAQ # Is JavaScript supposed to replace elisp? # The answer here is a loud NO. The maintainers love elisp and we will never remove elisp functionality from emacs-ng. JavaScript/TypeScript are peer languages in the emacs-ng ecosystem, meaning that if new maintainers want to write a package fully in JS/TS, they have that option. They have the full lisp API for interacting with the editor available to them. How should I use JS/TS as an existing package maintainer? # If you have a large elisp package, our guidance is not that you should rewrite your entire package in JS/TS. Instead, we encourage package maintainers to explore using JS/TS's Async I/O and Threading capabilities to improve performance their hot code paths on emacs-ng. Using (featurep 'emacs-ng) , you can include an import statement for a JS/TS package that defun's functions for you to use. Our Getting Started Guide is a good place to start. How does adding JS/TS affect your ability to merge future emacs improvements? # JS/TS is almost a completely additive layer, we have made extremely minimal C changes. As of writing this FAQ, we have only made a small edit to a single line of C to support JS/TS. WebRender, while still in development, has also made minimal C changes. We have the ability to cleanly merge upstream patches without conflict. emacs-ng is based off of the native-comp branch of emacs, and regularly merges in the latest from that branch. emacs-ng can be compiled with nativecomp using ./configure --with-native-compilation . How does JS/TS running affect performance? # JS/TS is a \"you pay for what you use\" system. The JS runtime starts uninitialized, and will not be initialized until you run JavaScript. The JS/TS event loop only runs when you have a pending async operation, including timer callbacks. If you don't have any pending promises/callbacks, the event loop isn't running. This means that impact is proportional to how you use the runtime. If I'm chasing performance, why not just write a C/Rust module? # JS/TS features faster iteration speed and easier distribution for you as the developer. In addition, your users get a greater deal of freedom and customization for your package because it's all in the scripting layer, as opposed to a binary blob they would have to recompile if they wanted to edit the behavior of the code. Instead of building your .so, uploading to a package repository, and dealing with user complaints when that .so isn't loaded properly, you can distribute your script files and still get a considerable performance increase. Will you provide TypeScript definitions for elisp functions? # We do not currently offer that, but it is planned work. We welcome contributions for that effort. emacs-ng seems to be using a large amount of virtual memory? # This is due to Tokio/v8 loading up a potentially large number of worker threads based on your core count. You will notice that real memory committed goes up very little from initializing the runtime. In standard emacs, we have observed emacs sitting at about 700K rss vs 900K rss with the JS runtime initialized. Overall, the real memory overhead of initializing is not as bad as the virtual commitment makes it seem. I have an existing node package I want to use, but import isn't working # We use the Deno Framework for our JavaScript. Deno uses actual ES6 imports, and not node's commonJS require syntax. You will need to use Deno's compatability module to use require syntax. See https://github.com/denoland/deno/tree/master/std/node","title":"FAQ"},{"location":"faq/#javascript-faq","text":"","title":"JavaScript FAQ"},{"location":"faq/#is-javascript-supposed-to-replace-elisp","text":"The answer here is a loud NO. The maintainers love elisp and we will never remove elisp functionality from emacs-ng. JavaScript/TypeScript are peer languages in the emacs-ng ecosystem, meaning that if new maintainers want to write a package fully in JS/TS, they have that option. They have the full lisp API for interacting with the editor available to them.","title":"Is JavaScript supposed to replace elisp?"},{"location":"faq/#how-should-i-use-jsts-as-an-existing-package-maintainer","text":"If you have a large elisp package, our guidance is not that you should rewrite your entire package in JS/TS. Instead, we encourage package maintainers to explore using JS/TS's Async I/O and Threading capabilities to improve performance their hot code paths on emacs-ng. Using (featurep 'emacs-ng) , you can include an import statement for a JS/TS package that defun's functions for you to use. Our Getting Started Guide is a good place to start.","title":"How should I use JS/TS as an existing package maintainer?"},{"location":"faq/#how-does-adding-jsts-affect-your-ability-to-merge-future-emacs-improvements","text":"JS/TS is almost a completely additive layer, we have made extremely minimal C changes. As of writing this FAQ, we have only made a small edit to a single line of C to support JS/TS. WebRender, while still in development, has also made minimal C changes. We have the ability to cleanly merge upstream patches without conflict. emacs-ng is based off of the native-comp branch of emacs, and regularly merges in the latest from that branch. emacs-ng can be compiled with nativecomp using ./configure --with-native-compilation .","title":"How does adding JS/TS affect your ability to merge future emacs improvements?"},{"location":"faq/#how-does-jsts-running-affect-performance","text":"JS/TS is a \"you pay for what you use\" system. The JS runtime starts uninitialized, and will not be initialized until you run JavaScript. The JS/TS event loop only runs when you have a pending async operation, including timer callbacks. If you don't have any pending promises/callbacks, the event loop isn't running. This means that impact is proportional to how you use the runtime.","title":"How does JS/TS running affect performance?"},{"location":"faq/#if-im-chasing-performance-why-not-just-write-a-crust-module","text":"JS/TS features faster iteration speed and easier distribution for you as the developer. In addition, your users get a greater deal of freedom and customization for your package because it's all in the scripting layer, as opposed to a binary blob they would have to recompile if they wanted to edit the behavior of the code. Instead of building your .so, uploading to a package repository, and dealing with user complaints when that .so isn't loaded properly, you can distribute your script files and still get a considerable performance increase.","title":"If I'm chasing performance, why not just write a C/Rust module?"},{"location":"faq/#will-you-provide-typescript-definitions-for-elisp-functions","text":"We do not currently offer that, but it is planned work. We welcome contributions for that effort.","title":"Will you provide TypeScript definitions for elisp functions?"},{"location":"faq/#emacs-ng-seems-to-be-using-a-large-amount-of-virtual-memory","text":"This is due to Tokio/v8 loading up a potentially large number of worker threads based on your core count. You will notice that real memory committed goes up very little from initializing the runtime. In standard emacs, we have observed emacs sitting at about 700K rss vs 900K rss with the JS runtime initialized. Overall, the real memory overhead of initializing is not as bad as the virtual commitment makes it seem.","title":"emacs-ng seems to be using a large amount of virtual memory?"},{"location":"faq/#i-have-an-existing-node-package-i-want-to-use-but-import-isnt-working","text":"We use the Deno Framework for our JavaScript. Deno uses actual ES6 imports, and not node's commonJS require syntax. You will need to use Deno's compatability module to use require syntax. See https://github.com/denoland/deno/tree/master/std/node","title":"I have an existing node package I want to use, but import isn't working"},{"location":"getting-started/","text":"Getting Started # This is an introduction for building applications and hacking on emacs-ng using JavaScript. emacs-ng supports both TypeScript and JavaScript, so these examples will feature both languages. This guide uses emacs terminology for key binds, i.e. C-x means holding down control and pressing x. M-x means holding Alt and pressing x (unless you are on a system where Escape is the 'Meta' key). C-x C-f means hold down control, press x, keep holding control, press f. Requirements # You will need Rust installed . The file rust-toolchain indicates the version that gets installed. This happens automatically, so don't override the toolchain manually. IMPORTANT: Whenever the toolchain updates, you have to reinstall rustfmt manually. You will need a C compiler and toolchain. On Linux, you can do something like: apt install build-essential automake clang libclang-dev On macOS, you'll need Xcode. Linux: apt install texinfo libjpeg-dev libtiff-dev \\ libgif-dev libxpm-dev libgtk-3-dev gnutls-dev \\ libncurses5-dev libxml2-dev libxt-dev macOS: brew install gnutls texinfo autoconf To use the installed version of `makeinfo` instead of the built - in ( `/usr/bin/makeinfo` ) one , you 'll need to make sure `/usr/local/opt/texinfo/bin` is before `/usr/bin` in `PATH`. Mojave install libxml2 headers with: `open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg` If you want to run doomemacs, you will need to compile with ./configure --with-nativecomp . nativecomp will also require zlib1g-dev libgccjit-9-dev Building # $ ./autogen.sh $ ./configure --enable-rust-debug $ make -j 8 # or your number of cores For a release build, don't pass --enable-rust-debug . The Makefile obeys cargo's RUSTFLAGS variable and additional options can be passed to cargo with CARGO_FLAGS. For example: $ make CARGO_FLAGS = \"-vv\" RUSTFLAGS = \"-Zunstable-options --cfg MARKER_DEBUG\" If you want to install it, just use make install You may need to run sudo make install depending on your system configuration. Now emacs should be available at ./src/emacs . We can launch the application via ./src/emacs . We can navigate to the lisp scratchpad by pressing C-x b and hitting enter. Type in the following line and press C-j ( eval-js \"lisp.print('hello world!')\" ) This will display \"hello world\" in your display area (along with 'nil' - we will get to that). This is an anonymous javascript evaluation. Before we go further, let\u2019s make an environment for working with our new scripting language. Running JavaScript # We have multiple ways to run JavaScript. Let us open a new TypeScript file by creating a file name \"basic.ts\" in our current directory. It will look something like: declare var lisp : any ; let x : string = \"Hello TypeScript\" ; lisp . print ( x ); Now we go back to *scratch* and run ( eval-js-file \"./basic.ts\" ) This is a relative filepath, and it works off of emacs current working directory (cwd). If you are in doubt to what emacs cwd is, just run the lisp function (pwd) in the lisp scratchpad You should see \"Hello TypeScript\" printed. All of the eval-js* functions return nil. If you want to use a calculated value from JavaScript in Lisp, you should use eval-js-literally . If you are looking for something like eval-expression , which is normally bound to M-:, you should use eval-js-expression . It accepts the same arguments as eval-expression , except with the first argument being a JavaScript expression, and behaves very similarly to eval-expression . It will also inserts the results into values just like eval-expression . eval-js-literally and eval-js-expression do not work with TypeScript at this time. Iteration # Now that we have our TypeScript file, let us get out of lisp and work purely in TypeScript. Open \"basic.ts\" by pressing C-x C-f and open \"basic.ts\". Press M-x and enter \"eval-ts-buffer\". This will evaluate the current contents of your buffer as typescript. You should see \"Hello Typescript\" print in your minibuffer. From now on, this will be our preferred way to iterate. If you do not want to evaluate the entire buffer, you can press C-space, highlight a region of code, and press M-x eval-ts-region. Try that with this code and see what happens: let y : string = 3 ; You will see the following error in your minibuffer: TS2322 [ ERROR ] : Type 'number' is not assignable to type 'string' . let y: string = 3 ; ^ at file:///home/user/ $anon$lisp$91610855413 .ts:1:5TS2322 It's important to understand that your TypeScript code is compiled prior to execution - unlike standard JavaScript which is evaluated until you encounter a runtime error. Within emacs-ng, that means that your code isn't executed if you have a type error in TypeScript. If these typescript examples are taking a long time to evaluate, it's likely due to the processing power required to compile everything. If you want to turn off TypeScript typechecking for the remainder of the examples, you can run: ( js-cleanup ) ( js-initialize :no-check t ) This code will cleanup your current JS environment and re-initialize it with TypeScript type checking disabled. If you do not care about the type checking that TypeScript offers, or your computer struggles with the cost of compiling, you can add (js-initialize :no-check t) to your init.el. Let's stop printing to the minibuffer, and instead start pushing our results into buffers. Let's start by something simple: make a network call and dump the results into a buffer. Buffers # First thing first, let's make our network call. In order to do this, we will use our built-in Deno APIs . Deno implements fetch , which looks something like this: declare var lisp : any ; fetch ( \"https://api.github.com/users/denoland\" ) . then ( response => response . json ()) . catch ( e => lisp . print ( JSON . stringify ( e ))); fetch is a common API documented here . It returns a Promise , which is a tool we will use to manage async I/O operations. Here, the network call isn't blocking, and it managed by our Rust runtime called Tokio. The .then is saying that once this promise is resolved, execute the next function in the chain. We have added a .catch , which will be executed if fetch errors. NOTE: If you have an unhandled toplevel promise rejection, the JavaScript runtime will RESET. You should always have a toplevel promise handler within any emacs-ng code. We will see the way we can interface with lisp error handling further on. However we want to put this response into a buffer. In order to do this, we will extend our .then chain, like so declare var lisp : any ; fetch ( \"https://api.github.com/users/denoland\" ) . then ( response => response . json ()) . then (( data ) => { const buffer = lisp . get_buffer_create ( \"TypeScript Buffer\" ); lisp . with_current_buffer ( buffer , () => lisp . insert ( JSON . stringify ( data ))); }) . catch ( e => lisp . print ( JSON . stringify ( e ))); Wait for the network call to resolve, and navigate to \"TypeScript Buffer\" via C-x b and typing in \"TypeScript Buffer\", or pressing C-x C-b and selecting our buffer from the buffer list. By now, you may be wondering about this lisp object, and how we are able to get references to lisp objects from JavaScript. Our next example should illustrate this further. Filewatching # Let's write an async filewatch that logs changes to a directory into a buffer, with a little extra data. In order to do this, we will use Deno's standard library. Deno has built in functions like fetch , along with a robust standard library that you need to import. That will look like this: declare var lisp : any ; // This will allow us to write const insertIntoTypeScriptBuffer = ( str : string ) => { const buffer = lisp . get_buffer_create ( \"TypeScript Filewatching\" ); lisp . with_current_buffer ( buffer , () => lisp . insert ( ` ${ str } \\n` )); }; async function watch ( dir : string ) { const watcher = Deno . watchFs ( dir ); let i = 0 ; for await ( const event of watcher ) { i += 1 ; if ( i > 5 ) break ; insertIntoTypeScriptBuffer ( JSON . stringify ( event )); } } watch ( '.' ) This example is built to only record 5 events prior to ending itself. You can write whatever logic you would like for ending your filewatcher. running touch foo.ts in your current directory should yield something like the following in the \"TypeScript Filewatching\" buffer { \"kind\" : \"create\" , \"paths\" :[ \"/home/user/./foo.ts\" ]} { \"kind\" : \"modify\" , \"paths\" :[ \"/home/user/./foo.ts\" ]} { \"kind\" : \"access\" , \"paths\" :[ \"/home/user/./foo.ts\" ]} Deno has further documentation on this . Note that these events can differ per operating system. A few key take aways here - all of the TypeScript written above is executed on the Main elisp thread - there are no race conditions with lisp here. Even though the filewatcher is async, it calls back onto the mainthread when it has data. Multithreaded scripting is possible and will be covered later on. Modules # Now let's look at our tools for importing code. emacs-ng supports ES6 modules . emacs-ng does not support node's require syntax. See the \"Using Deno\" section for more information on modules. Let's create a submodule for our main program. Create a file named \"mod-sub.js\": export function generateRandomNumber () { return 4 ; } Now in our main file, we can add the following to the top of our file: import { generateRandomNumber } from \"./mod-sub.js\" ; declare var lisp : any ; lisp . print ( generateRandomNumber ()); Even though our module is TypeScript, we can still import plain old JavaScript. It's important to note that ES6 modules are supposed to be immutable. What does that mean? If we were to edit mod-js to include the following: export function generateRandomNumber () { return 4 ; } lisp . print ( generateRandomNumber ()); We see that in addition to exporting a function, we execute code with side-effects (printing). Those side-effects only happen once . If I import mod-sub multiple times, I will only ever see \"4\" printed once. Another important note is that this rule does not apply to any toplevel module you execute . Meaning that if you call (eval-js-file \"./basic.ts\") multiple times, your code is executed every single time, however your dependencies are only executed once. This is by design. If you want to break this, you can append a number to your dependency and use so-called dynamic importing , like so: declare var lisp : any ; let timestamp : number = Date . now (); const { generateRandomNumber } = await import ( `./mod-sub.js# ${ timestamp } ` ); lisp . print ( generateRandomNumber ()); This can be useful if you are a module developer and you want to iterate on your modules within emacs-ng. It is recommended that you do not ship your modules using this pattern, as it will not cache results properly and lead to a susoptimal user experience. Your imports should aim to not have side effects, and instead should only export functions or variables to be used by your main module. The intended use of Dynamic Importing is to allow you to have condition imports, like so: if ( myCondition ) { const { func } = await import ( 'example-mod.js' ); func (); } Lisp Interaction # The lisp object is magic - it has (almost) all lisp functions defined on it, including any functions defined in your custom packages. If you can invoke it via (funcall ....) , you can call it via the lisp object if you change - for _ . For example: (with-current-buffer (get-buffer-create \"BUFFER\") (lambda () (insert \"DATA\"))) becomes lisp . with_current_buffer ( lisp . get_buffer_create ( \"BUFFER\" ), () => lisp . insert ( \"DATA\" )); We have implementations of common macros like with-current-buffer . If you find that a certain common macro doesn't work, you can report it to the project's maintainers and they will implement it, however what they are doing isn't magic - they are just calling eval on your whatever macro you want to invoke from JavaScript. lisp . eval ( lisp . list ( lisp . symbols . with_current_buffer , arg1 , arg2 )); You can override the behavior of the lisp object via the special object specialForms , which looks like lisp . specialForms . with_current_buffer = myWithCurrentBufferFunction ; This overrides JavaScript's implementation of with_current_buffer without touching lisp's implementation. Let's discuss working with lisp more: Lisp Primitives # Primitives (Number, String, Boolean) are automatically translated when calling lisp functions lisp . my_function ( 1.0 , 2 , \"MYSTRING\" , false ) If you need to access a symbol or keyword, you will use the symbol keyword objects const mySymbol = lisp . symbols . foo ; // foo const myKeyword = lisp . keywords . foo ; // :foo You can create more complex objects via the make object const hashtable = lisp . make . hashtable ({ x : 3 , y : 4 }); const alist = lisp . make . alist ({ x : lisp.symbols.bar , y : \"String\" }); const plist = lisp . make . plist ({ zz : 19 , zx : false }); const array = lisp . make . array ([ 1 , 2 , 3 , 4 , 5 ]); const list = lisp . make . list ([ 1 , 5 , \"String\" , lisp . symbols . x ]); const lstring = lisp . make . string ( \"MyString\" ); Errors # If a lisp function would trigger (error ...) in lisp, it will throw an error in javascript. An example: try { lisp . cons (); // No arguments } catch ( e ) { lisp . print ( JSON . stringify ( e )); } Defining Lisp Functions # We can also define functions that can be called via lisp. We will use defun to accomplish this: declare var lisp : any ; const insertIntoTypeScriptBuffer = ( str : string ) => { const buffer = lisp . get_buffer_create ( \"TypeScript Filewatching\" ); lisp . with_current_buffer ( buffer , () => lisp . insert ( str )); }; lisp . defun ({ name : \"my-function\" , docString : \"My Example Function\" , interactive : true , args : \"MInput\" , func : ( str : string ) => insertIntoTypeScriptBuffer ( str ) }); This defines a lisp function named my-function . We can call this function from lisp (my-function STRING) , in JavaScript via lisp.my_function(STRING) , or call it interactively. That means that within the editor if we press M-x and type \"my-function\", we can invoke the function. It will then perform our JavaScript action, which is to insert whatever text we enter into our TypeScript Buffer. Conclusion # This covers the basic of calling lisp functions and I/O using Deno. Together using these tools you can already build powerful apps, or allow emacs-ng to perform actions. In our next series we will cover more advanced topics like Threading and WebASM.","title":"Getting started"},{"location":"getting-started/#getting-started","text":"This is an introduction for building applications and hacking on emacs-ng using JavaScript. emacs-ng supports both TypeScript and JavaScript, so these examples will feature both languages. This guide uses emacs terminology for key binds, i.e. C-x means holding down control and pressing x. M-x means holding Alt and pressing x (unless you are on a system where Escape is the 'Meta' key). C-x C-f means hold down control, press x, keep holding control, press f.","title":"Getting Started"},{"location":"getting-started/#requirements","text":"You will need Rust installed . The file rust-toolchain indicates the version that gets installed. This happens automatically, so don't override the toolchain manually. IMPORTANT: Whenever the toolchain updates, you have to reinstall rustfmt manually. You will need a C compiler and toolchain. On Linux, you can do something like: apt install build-essential automake clang libclang-dev On macOS, you'll need Xcode. Linux: apt install texinfo libjpeg-dev libtiff-dev \\ libgif-dev libxpm-dev libgtk-3-dev gnutls-dev \\ libncurses5-dev libxml2-dev libxt-dev macOS: brew install gnutls texinfo autoconf To use the installed version of `makeinfo` instead of the built - in ( `/usr/bin/makeinfo` ) one , you 'll need to make sure `/usr/local/opt/texinfo/bin` is before `/usr/bin` in `PATH`. Mojave install libxml2 headers with: `open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg` If you want to run doomemacs, you will need to compile with ./configure --with-nativecomp . nativecomp will also require zlib1g-dev libgccjit-9-dev","title":"Requirements"},{"location":"getting-started/#building","text":"$ ./autogen.sh $ ./configure --enable-rust-debug $ make -j 8 # or your number of cores For a release build, don't pass --enable-rust-debug . The Makefile obeys cargo's RUSTFLAGS variable and additional options can be passed to cargo with CARGO_FLAGS. For example: $ make CARGO_FLAGS = \"-vv\" RUSTFLAGS = \"-Zunstable-options --cfg MARKER_DEBUG\" If you want to install it, just use make install You may need to run sudo make install depending on your system configuration. Now emacs should be available at ./src/emacs . We can launch the application via ./src/emacs . We can navigate to the lisp scratchpad by pressing C-x b and hitting enter. Type in the following line and press C-j ( eval-js \"lisp.print('hello world!')\" ) This will display \"hello world\" in your display area (along with 'nil' - we will get to that). This is an anonymous javascript evaluation. Before we go further, let\u2019s make an environment for working with our new scripting language.","title":"Building"},{"location":"getting-started/#running-javascript","text":"We have multiple ways to run JavaScript. Let us open a new TypeScript file by creating a file name \"basic.ts\" in our current directory. It will look something like: declare var lisp : any ; let x : string = \"Hello TypeScript\" ; lisp . print ( x ); Now we go back to *scratch* and run ( eval-js-file \"./basic.ts\" ) This is a relative filepath, and it works off of emacs current working directory (cwd). If you are in doubt to what emacs cwd is, just run the lisp function (pwd) in the lisp scratchpad You should see \"Hello TypeScript\" printed. All of the eval-js* functions return nil. If you want to use a calculated value from JavaScript in Lisp, you should use eval-js-literally . If you are looking for something like eval-expression , which is normally bound to M-:, you should use eval-js-expression . It accepts the same arguments as eval-expression , except with the first argument being a JavaScript expression, and behaves very similarly to eval-expression . It will also inserts the results into values just like eval-expression . eval-js-literally and eval-js-expression do not work with TypeScript at this time.","title":"Running JavaScript"},{"location":"getting-started/#iteration","text":"Now that we have our TypeScript file, let us get out of lisp and work purely in TypeScript. Open \"basic.ts\" by pressing C-x C-f and open \"basic.ts\". Press M-x and enter \"eval-ts-buffer\". This will evaluate the current contents of your buffer as typescript. You should see \"Hello Typescript\" print in your minibuffer. From now on, this will be our preferred way to iterate. If you do not want to evaluate the entire buffer, you can press C-space, highlight a region of code, and press M-x eval-ts-region. Try that with this code and see what happens: let y : string = 3 ; You will see the following error in your minibuffer: TS2322 [ ERROR ] : Type 'number' is not assignable to type 'string' . let y: string = 3 ; ^ at file:///home/user/ $anon$lisp$91610855413 .ts:1:5TS2322 It's important to understand that your TypeScript code is compiled prior to execution - unlike standard JavaScript which is evaluated until you encounter a runtime error. Within emacs-ng, that means that your code isn't executed if you have a type error in TypeScript. If these typescript examples are taking a long time to evaluate, it's likely due to the processing power required to compile everything. If you want to turn off TypeScript typechecking for the remainder of the examples, you can run: ( js-cleanup ) ( js-initialize :no-check t ) This code will cleanup your current JS environment and re-initialize it with TypeScript type checking disabled. If you do not care about the type checking that TypeScript offers, or your computer struggles with the cost of compiling, you can add (js-initialize :no-check t) to your init.el. Let's stop printing to the minibuffer, and instead start pushing our results into buffers. Let's start by something simple: make a network call and dump the results into a buffer.","title":"Iteration"},{"location":"getting-started/#buffers","text":"First thing first, let's make our network call. In order to do this, we will use our built-in Deno APIs . Deno implements fetch , which looks something like this: declare var lisp : any ; fetch ( \"https://api.github.com/users/denoland\" ) . then ( response => response . json ()) . catch ( e => lisp . print ( JSON . stringify ( e ))); fetch is a common API documented here . It returns a Promise , which is a tool we will use to manage async I/O operations. Here, the network call isn't blocking, and it managed by our Rust runtime called Tokio. The .then is saying that once this promise is resolved, execute the next function in the chain. We have added a .catch , which will be executed if fetch errors. NOTE: If you have an unhandled toplevel promise rejection, the JavaScript runtime will RESET. You should always have a toplevel promise handler within any emacs-ng code. We will see the way we can interface with lisp error handling further on. However we want to put this response into a buffer. In order to do this, we will extend our .then chain, like so declare var lisp : any ; fetch ( \"https://api.github.com/users/denoland\" ) . then ( response => response . json ()) . then (( data ) => { const buffer = lisp . get_buffer_create ( \"TypeScript Buffer\" ); lisp . with_current_buffer ( buffer , () => lisp . insert ( JSON . stringify ( data ))); }) . catch ( e => lisp . print ( JSON . stringify ( e ))); Wait for the network call to resolve, and navigate to \"TypeScript Buffer\" via C-x b and typing in \"TypeScript Buffer\", or pressing C-x C-b and selecting our buffer from the buffer list. By now, you may be wondering about this lisp object, and how we are able to get references to lisp objects from JavaScript. Our next example should illustrate this further.","title":"Buffers"},{"location":"getting-started/#filewatching","text":"Let's write an async filewatch that logs changes to a directory into a buffer, with a little extra data. In order to do this, we will use Deno's standard library. Deno has built in functions like fetch , along with a robust standard library that you need to import. That will look like this: declare var lisp : any ; // This will allow us to write const insertIntoTypeScriptBuffer = ( str : string ) => { const buffer = lisp . get_buffer_create ( \"TypeScript Filewatching\" ); lisp . with_current_buffer ( buffer , () => lisp . insert ( ` ${ str } \\n` )); }; async function watch ( dir : string ) { const watcher = Deno . watchFs ( dir ); let i = 0 ; for await ( const event of watcher ) { i += 1 ; if ( i > 5 ) break ; insertIntoTypeScriptBuffer ( JSON . stringify ( event )); } } watch ( '.' ) This example is built to only record 5 events prior to ending itself. You can write whatever logic you would like for ending your filewatcher. running touch foo.ts in your current directory should yield something like the following in the \"TypeScript Filewatching\" buffer { \"kind\" : \"create\" , \"paths\" :[ \"/home/user/./foo.ts\" ]} { \"kind\" : \"modify\" , \"paths\" :[ \"/home/user/./foo.ts\" ]} { \"kind\" : \"access\" , \"paths\" :[ \"/home/user/./foo.ts\" ]} Deno has further documentation on this . Note that these events can differ per operating system. A few key take aways here - all of the TypeScript written above is executed on the Main elisp thread - there are no race conditions with lisp here. Even though the filewatcher is async, it calls back onto the mainthread when it has data. Multithreaded scripting is possible and will be covered later on.","title":"Filewatching"},{"location":"getting-started/#modules","text":"Now let's look at our tools for importing code. emacs-ng supports ES6 modules . emacs-ng does not support node's require syntax. See the \"Using Deno\" section for more information on modules. Let's create a submodule for our main program. Create a file named \"mod-sub.js\": export function generateRandomNumber () { return 4 ; } Now in our main file, we can add the following to the top of our file: import { generateRandomNumber } from \"./mod-sub.js\" ; declare var lisp : any ; lisp . print ( generateRandomNumber ()); Even though our module is TypeScript, we can still import plain old JavaScript. It's important to note that ES6 modules are supposed to be immutable. What does that mean? If we were to edit mod-js to include the following: export function generateRandomNumber () { return 4 ; } lisp . print ( generateRandomNumber ()); We see that in addition to exporting a function, we execute code with side-effects (printing). Those side-effects only happen once . If I import mod-sub multiple times, I will only ever see \"4\" printed once. Another important note is that this rule does not apply to any toplevel module you execute . Meaning that if you call (eval-js-file \"./basic.ts\") multiple times, your code is executed every single time, however your dependencies are only executed once. This is by design. If you want to break this, you can append a number to your dependency and use so-called dynamic importing , like so: declare var lisp : any ; let timestamp : number = Date . now (); const { generateRandomNumber } = await import ( `./mod-sub.js# ${ timestamp } ` ); lisp . print ( generateRandomNumber ()); This can be useful if you are a module developer and you want to iterate on your modules within emacs-ng. It is recommended that you do not ship your modules using this pattern, as it will not cache results properly and lead to a susoptimal user experience. Your imports should aim to not have side effects, and instead should only export functions or variables to be used by your main module. The intended use of Dynamic Importing is to allow you to have condition imports, like so: if ( myCondition ) { const { func } = await import ( 'example-mod.js' ); func (); }","title":"Modules"},{"location":"getting-started/#lisp-interaction","text":"The lisp object is magic - it has (almost) all lisp functions defined on it, including any functions defined in your custom packages. If you can invoke it via (funcall ....) , you can call it via the lisp object if you change - for _ . For example: (with-current-buffer (get-buffer-create \"BUFFER\") (lambda () (insert \"DATA\"))) becomes lisp . with_current_buffer ( lisp . get_buffer_create ( \"BUFFER\" ), () => lisp . insert ( \"DATA\" )); We have implementations of common macros like with-current-buffer . If you find that a certain common macro doesn't work, you can report it to the project's maintainers and they will implement it, however what they are doing isn't magic - they are just calling eval on your whatever macro you want to invoke from JavaScript. lisp . eval ( lisp . list ( lisp . symbols . with_current_buffer , arg1 , arg2 )); You can override the behavior of the lisp object via the special object specialForms , which looks like lisp . specialForms . with_current_buffer = myWithCurrentBufferFunction ; This overrides JavaScript's implementation of with_current_buffer without touching lisp's implementation. Let's discuss working with lisp more:","title":"Lisp Interaction"},{"location":"getting-started/#lisp-primitives","text":"Primitives (Number, String, Boolean) are automatically translated when calling lisp functions lisp . my_function ( 1.0 , 2 , \"MYSTRING\" , false ) If you need to access a symbol or keyword, you will use the symbol keyword objects const mySymbol = lisp . symbols . foo ; // foo const myKeyword = lisp . keywords . foo ; // :foo You can create more complex objects via the make object const hashtable = lisp . make . hashtable ({ x : 3 , y : 4 }); const alist = lisp . make . alist ({ x : lisp.symbols.bar , y : \"String\" }); const plist = lisp . make . plist ({ zz : 19 , zx : false }); const array = lisp . make . array ([ 1 , 2 , 3 , 4 , 5 ]); const list = lisp . make . list ([ 1 , 5 , \"String\" , lisp . symbols . x ]); const lstring = lisp . make . string ( \"MyString\" );","title":"Lisp Primitives"},{"location":"getting-started/#errors","text":"If a lisp function would trigger (error ...) in lisp, it will throw an error in javascript. An example: try { lisp . cons (); // No arguments } catch ( e ) { lisp . print ( JSON . stringify ( e )); }","title":"Errors"},{"location":"getting-started/#defining-lisp-functions","text":"We can also define functions that can be called via lisp. We will use defun to accomplish this: declare var lisp : any ; const insertIntoTypeScriptBuffer = ( str : string ) => { const buffer = lisp . get_buffer_create ( \"TypeScript Filewatching\" ); lisp . with_current_buffer ( buffer , () => lisp . insert ( str )); }; lisp . defun ({ name : \"my-function\" , docString : \"My Example Function\" , interactive : true , args : \"MInput\" , func : ( str : string ) => insertIntoTypeScriptBuffer ( str ) }); This defines a lisp function named my-function . We can call this function from lisp (my-function STRING) , in JavaScript via lisp.my_function(STRING) , or call it interactively. That means that within the editor if we press M-x and type \"my-function\", we can invoke the function. It will then perform our JavaScript action, which is to insert whatever text we enter into our TypeScript Buffer.","title":"Defining Lisp Functions"},{"location":"getting-started/#conclusion","text":"This covers the basic of calling lisp functions and I/O using Deno. Together using these tools you can already build powerful apps, or allow emacs-ng to perform actions. In our next series we will cover more advanced topics like Threading and WebASM.","title":"Conclusion"},{"location":"main-features/","text":"Main Features # Javascript # This code is a strictly additive layer, it changes no elisp functionality, and should be able to merge upstream patches cleanly. JS tests can be run by building the editor and executing cd test/js && ../../src/emacs --batch --eval '(deno \"test\" \"--allow-read\" \"--allow-write\" \"main.js\")' . To learn more about JavaScript and TypeScript, it is recommended you check out Getting Started , Using Deno , and Advanced Features Using Async I/O # We expose the async IO functionality included with deno. Users can fetch data async from their local file system, or the network. They can use that data to interact with the editor. An example would be: const json = fetch ( \"https://api.github.com/users/denoland\" ) . then (( response ) => { return response . json (); }); const txt = Deno . readTextFile ( \"./test.json\" ); Promise . all ([ json , text ]) . then (( data ) => { let buffer = lisp . get_buffer_create ( 'hello' ); const current = lisp . current_buffer (); lisp . set_buffer ( buffer ); lisp . insert ( JSON . stringify ( data [ 0 ])); lisp . insert ( data [ 1 ]); console . log ( lisp . buffer_string ()); lisp . set_buffer ( current ); }); This example assumes you have a json file named test.json in your current directory. WebWorkers and Parallel Scripting # We also support WebWorkers, meaning that you can run javascript in separate threads. Note that WebWorkers cannot interact with the lisp VM, however they can use Deno for async I/O. See Advanced Features Web Assembly allows you to perform things normally handled by native libraries with easy distribution. Want to manipulate sqlite3? Use the deno sqlite wasm package import { DB } from \"https://deno.land/x/sqlite@v2.3.2/mod.ts\" ; const db = new DB ( \"test.db\" ); db . query ( \"CREATE TABLE IF NOT EXISTS people (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT)\" ); const name = \"David\" ; db . query ( \"INSERT INTO people (name) VALUES (?)\" , [ name ]); for ( const [ name ] of db . query ( \"SELECT name FROM people\" )) { console . log ( name ); } db . close (); Webrender # WebRender is a GPU-based 2D rendering engine written in Rust from Mozilla. Firefox, the research web browser Servo, and other GUI frameworks draw with it. emacs-ng use it as a new experimental graphic backend to leverage GPU hardware. Webrender rendering is a opt-in feature. You can enable it by this. $ ./configure --with-webrender If you get \"Couldn't find any available vsync extension\" runtime panic, enabling 3D acceleration will fixes it.","title":"Basic features"},{"location":"main-features/#main-features","text":"","title":"Main Features"},{"location":"main-features/#javascript","text":"This code is a strictly additive layer, it changes no elisp functionality, and should be able to merge upstream patches cleanly. JS tests can be run by building the editor and executing cd test/js && ../../src/emacs --batch --eval '(deno \"test\" \"--allow-read\" \"--allow-write\" \"main.js\")' . To learn more about JavaScript and TypeScript, it is recommended you check out Getting Started , Using Deno , and Advanced Features","title":"Javascript"},{"location":"main-features/#using-async-io","text":"We expose the async IO functionality included with deno. Users can fetch data async from their local file system, or the network. They can use that data to interact with the editor. An example would be: const json = fetch ( \"https://api.github.com/users/denoland\" ) . then (( response ) => { return response . json (); }); const txt = Deno . readTextFile ( \"./test.json\" ); Promise . all ([ json , text ]) . then (( data ) => { let buffer = lisp . get_buffer_create ( 'hello' ); const current = lisp . current_buffer (); lisp . set_buffer ( buffer ); lisp . insert ( JSON . stringify ( data [ 0 ])); lisp . insert ( data [ 1 ]); console . log ( lisp . buffer_string ()); lisp . set_buffer ( current ); }); This example assumes you have a json file named test.json in your current directory.","title":"Using Async I/O"},{"location":"main-features/#webworkers-and-parallel-scripting","text":"We also support WebWorkers, meaning that you can run javascript in separate threads. Note that WebWorkers cannot interact with the lisp VM, however they can use Deno for async I/O. See Advanced Features Web Assembly allows you to perform things normally handled by native libraries with easy distribution. Want to manipulate sqlite3? Use the deno sqlite wasm package import { DB } from \"https://deno.land/x/sqlite@v2.3.2/mod.ts\" ; const db = new DB ( \"test.db\" ); db . query ( \"CREATE TABLE IF NOT EXISTS people (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT)\" ); const name = \"David\" ; db . query ( \"INSERT INTO people (name) VALUES (?)\" , [ name ]); for ( const [ name ] of db . query ( \"SELECT name FROM people\" )) { console . log ( name ); } db . close ();","title":"WebWorkers and Parallel Scripting"},{"location":"main-features/#webrender","text":"WebRender is a GPU-based 2D rendering engine written in Rust from Mozilla. Firefox, the research web browser Servo, and other GUI frameworks draw with it. emacs-ng use it as a new experimental graphic backend to leverage GPU hardware. Webrender rendering is a opt-in feature. You can enable it by this. $ ./configure --with-webrender If you get \"Couldn't find any available vsync extension\" runtime panic, enabling 3D acceleration will fixes it.","title":"Webrender"},{"location":"ng-module/","text":"Dynamic Modules # Emacs-ng is always built with dynamic modules support enabled, and is fully compatible with dynamic modules written for \"vanilla\" Emacs. On top of the existing emacs-module.h interface, Emacs-ng provides additional extensions that allow dynamic modules to access more of Emacs's internals . Dynamic modules can be written to take advantage of these extra functionalities when they are available, while at the same time being fully compatible with vanilla Emacs. The additional extensions are exposed as a registry of named native functions that can be looked up at run time. These native functions are called ng-module functions : ELISP> ( ng-module-function-address \"ng_module_access_current_buffer_contents\" ) # <user-ptr ptr=0x10e31120d finalizer=0x0> ELISP> ( ng-module-function-address \"non_existing_or_removed_function\" ) nil Unlike normal module functions from emacs_env , these ng-module functions have globally stable addresses . Therefore, the lookup can (and should) be done once, at module load time, inside emacs_module_init . Also note that, even though the lookup function ng-module-function-address is available to Lisp code, it is intended to be used by dynamic modules' native code. (Lisp code cannot meaningfully use the returned address, anyway.) Once an ng-module function is added, its signature will not change. If a similar ng-module function with improved functionalities is added, it will be given a different name. However, a ng-module function can be removed . Direct access to buffer text # To access a buffer's text, a \"vanilla\" dynamic module has to call a buffer-to-string function, like buffer-substring , then call emacs_env->copy_string_contents (resulting in a memcpy ). The temporary Lisp string is typically discarded right away. This is a potential performance bottleneck in hot code paths, like emacs-tree-sitter 's parsing/querying. A dynamic module can instead use the ng-module function ng_module_access_current_buffer_contents to directly read a buffer's text, without copying, or creating a Lisp string. It returns the pointers to (and the sizes of) the 2 contiguous byte segments before and after the buffer's gap. The caller must not write through the returned pointers, and must ensure that the data is read before it is invalidated . Some operations that may invalidate the data are: buffer modifications, garbage collection (which can be triggered by uses of emacs_env ), arena compaction (which can be triggered by malloc when Emacs is built with REL_ALLOC ). Below is an example of how to use this function in a dynamic module written in Rust: use std :: mem :: { self , MaybeUninit }; use once_cell :: sync :: OnceCell ; use emacs :: Env ; type AccessBufferContents = unsafe fn ( * mut * const u8 , * mut isize , * mut * const u8 , * mut isize ); #[allow(non_upper_case_globals)] pub static ng_module_access_current_buffer_contents : OnceCell < AccessBufferContents > = OnceCell :: new (); #[emacs::module] fn init ( env : & Env ) -> Result < () > { let get_addr = env . call ( \"symbol-function\" , [ env . intern ( \"ng-module-function-address\" ) ? ]) ? ; // Got the registry. if get_addr . is_not_nil () { // Look up the ng-module function. match get_addr . call (( \"ng_module_access_current_buffer_contents\" ,)) ? . into_rust :: < Option < Value >> () ? { Some ( addr ) => { // Got the pointer, \"cast\" it to the signature promised by ng-module. buffer :: ng_module_access_current_buffer_contents . set ( unsafe { mem :: transmute ( addr . get_user_ptr () ? ) } ). unwrap (); } None => (), } } Ok (()) } pub unsafe fn current_buffer_contents ( _ : & Env ) -> ( & [ u8 ], & [ u8 ]) { let mut before_gap = MaybeUninit :: uninit (); let mut after_gap = MaybeUninit :: uninit (); let mut before_gap_size : isize = 0 ; let mut after_gap_size : isize = 0 ; let get_slices = ng_module_access_current_buffer_contents . get (). unwrap (); get_slices ( before_gap . as_mut_ptr (), & mut before_gap_size , after_gap . as_mut_ptr (), & mut after_gap_size , ); let before_gap_size = before_gap_size ; let after_gap_size = after_gap_size ; ( if before_gap_size > 0 { std :: slice :: from_raw_parts ( before_gap . assume_init (), before_gap_size as usize , ) } else { & [] }, if after_gap_size > 0 { std :: slice :: from_raw_parts ( after_gap . assume_init (), after_gap_size as usize , ) } else { & [] }, ) } A future version of emacs-module-rs may provide a more convenient wrapper for this function.","title":"Dynamic modules"},{"location":"ng-module/#dynamic-modules","text":"Emacs-ng is always built with dynamic modules support enabled, and is fully compatible with dynamic modules written for \"vanilla\" Emacs. On top of the existing emacs-module.h interface, Emacs-ng provides additional extensions that allow dynamic modules to access more of Emacs's internals . Dynamic modules can be written to take advantage of these extra functionalities when they are available, while at the same time being fully compatible with vanilla Emacs. The additional extensions are exposed as a registry of named native functions that can be looked up at run time. These native functions are called ng-module functions : ELISP> ( ng-module-function-address \"ng_module_access_current_buffer_contents\" ) # <user-ptr ptr=0x10e31120d finalizer=0x0> ELISP> ( ng-module-function-address \"non_existing_or_removed_function\" ) nil Unlike normal module functions from emacs_env , these ng-module functions have globally stable addresses . Therefore, the lookup can (and should) be done once, at module load time, inside emacs_module_init . Also note that, even though the lookup function ng-module-function-address is available to Lisp code, it is intended to be used by dynamic modules' native code. (Lisp code cannot meaningfully use the returned address, anyway.) Once an ng-module function is added, its signature will not change. If a similar ng-module function with improved functionalities is added, it will be given a different name. However, a ng-module function can be removed .","title":"Dynamic Modules"},{"location":"ng-module/#direct-access-to-buffer-text","text":"To access a buffer's text, a \"vanilla\" dynamic module has to call a buffer-to-string function, like buffer-substring , then call emacs_env->copy_string_contents (resulting in a memcpy ). The temporary Lisp string is typically discarded right away. This is a potential performance bottleneck in hot code paths, like emacs-tree-sitter 's parsing/querying. A dynamic module can instead use the ng-module function ng_module_access_current_buffer_contents to directly read a buffer's text, without copying, or creating a Lisp string. It returns the pointers to (and the sizes of) the 2 contiguous byte segments before and after the buffer's gap. The caller must not write through the returned pointers, and must ensure that the data is read before it is invalidated . Some operations that may invalidate the data are: buffer modifications, garbage collection (which can be triggered by uses of emacs_env ), arena compaction (which can be triggered by malloc when Emacs is built with REL_ALLOC ). Below is an example of how to use this function in a dynamic module written in Rust: use std :: mem :: { self , MaybeUninit }; use once_cell :: sync :: OnceCell ; use emacs :: Env ; type AccessBufferContents = unsafe fn ( * mut * const u8 , * mut isize , * mut * const u8 , * mut isize ); #[allow(non_upper_case_globals)] pub static ng_module_access_current_buffer_contents : OnceCell < AccessBufferContents > = OnceCell :: new (); #[emacs::module] fn init ( env : & Env ) -> Result < () > { let get_addr = env . call ( \"symbol-function\" , [ env . intern ( \"ng-module-function-address\" ) ? ]) ? ; // Got the registry. if get_addr . is_not_nil () { // Look up the ng-module function. match get_addr . call (( \"ng_module_access_current_buffer_contents\" ,)) ? . into_rust :: < Option < Value >> () ? { Some ( addr ) => { // Got the pointer, \"cast\" it to the signature promised by ng-module. buffer :: ng_module_access_current_buffer_contents . set ( unsafe { mem :: transmute ( addr . get_user_ptr () ? ) } ). unwrap (); } None => (), } } Ok (()) } pub unsafe fn current_buffer_contents ( _ : & Env ) -> ( & [ u8 ], & [ u8 ]) { let mut before_gap = MaybeUninit :: uninit (); let mut after_gap = MaybeUninit :: uninit (); let mut before_gap_size : isize = 0 ; let mut after_gap_size : isize = 0 ; let get_slices = ng_module_access_current_buffer_contents . get (). unwrap (); get_slices ( before_gap . as_mut_ptr (), & mut before_gap_size , after_gap . as_mut_ptr (), & mut after_gap_size , ); let before_gap_size = before_gap_size ; let after_gap_size = after_gap_size ; ( if before_gap_size > 0 { std :: slice :: from_raw_parts ( before_gap . assume_init (), before_gap_size as usize , ) } else { & [] }, if after_gap_size > 0 { std :: slice :: from_raw_parts ( after_gap . assume_init (), after_gap_size as usize , ) } else { & [] }, ) } A future version of emacs-module-rs may provide a more convenient wrapper for this function.","title":"Direct access to buffer text"},{"location":"using-deno/","text":"Using the power of Deno # What is Deno ? # Deno is a program that is similar to node.js, except it is written in Rust. Both Deno and nodejs were created by the same person, Ryan Dhal. While normally you would invoke Deno via the command line, the emacs-ng project has integrated the Deno runtime into the emacs-ng client directly. Deno is powered by v8, Chrome's Open Source JavaScript engine. A JavaScript engine is more limited then most users realize. For example, utilities like XMLHttpRequest are not provided directly by the JavaScript engine, but are instead provided by a runtime (like your browser). Deno provides interfaces for performing I/O operations like file reads/writes, network operations, and spawning subprocesses. By default, emacs-ng will allow reading, writing, network, and subprocess operations. In Deno's examples, you may see them advise you to pass flags like \"--allow-net\". These are not needed when executing emacs-ng code. If you want to globally disable any of the previously mentioned operations, you can run the following lisp prior to executing JavaScript: (js-initialize :allow-net nil :allow-read nil :allow-write nil :allow-run nil) You can define any combination of the above arguments. See js-initialize's documentation for more information. General Documentation / Standard Library # Deno has excellent documentation . This guide is to give you a basic familiarity with Deno to allow you to quickly write applications, but is FAR from all inclusive. Deno maintains a powerful standard library at https://deno.land/std@0.83.0 . Importing a deno std module is simple: just include this in your JavaScript file/buffer: Credit to https://deno.land/std@0.83.0/fs for the example: import { copy , copySync } from \"https://deno.land/std@0.83.0/fs/mod.ts\" ; copy ( \"./foo\" , \"./bar\" ); // returns a promise copySync ( \"./foo\" , \"./bar\" ); // void copySync ( \"./foo\" , \"./existingFolder\" , { overwrite : true }); The first thing you may notice is that we are importing a URL, not a local filepath. Deno allows you to download dependencies from the network. This file will only be downloaded once and compiled once, and it's results will be cached on your local file system. After initial download, you will use your local filesystem's copy instead of using the network. By default, all Deno API's are asynchronous . Almost all async operations have an alternate version that is synchronous. That means that when you make a call to read a file, or walk a directory, it is returning a Promise. Deno has the naming convention that the synchronous versions all end in \" Sync\". A common point of confusion with emacs-ng is that when you evaluate a file, a buffer, or even an anonymous block in JavaScript via (eval-js) , you are executing your code within a JavaScript module with toplevel await enabled. What does that mean? If you invoke await within your toplevel module, you will block the main thread until completion. Looking again with our example above with that in mind: import { copy } from \"https://deno.land/std@0.83.0/fs/mod.ts\" ; // This block the main thread, including lisp execution, until this action is completed await copy ( \"./foo\" , \"./bar\" ); // This does not block JavaScript or Lisp, instead our .then will be executed once // the async action is complete. copy ( \"./foo\" , \"./bar\" ). then (() => console . log ( \"Complete\" )); Remember that async/await in JavaScript is just syntax sugar over Promises. There may be times where you want to use the toplevel await functionality to block on a promise at a certain time. Distribution # Once you have created your great emacs-ng module, how do you distribute it? Normally you would go through a repository like ELPA or MELPLA. While that is still a possibility, you have a third option, which is Deno's user modules . Navigating to the link below gives you the information on the upload process, but in the author's opinion, it is very simple and streamlined. Once your module is uploaded, you can have your user's include a line similar to this in their init.el (eval-js \"import 'https://deno.land/x/fuzzy_search@0.3.0/mod-fuzzy.js'\") Where instead of fuzzy_search@0.3.0/mod-fuzzy.js, you instead have your module version and filename. Using emacs as deno # emacs-ng offers the deno function in elisp, which allows users to leverage whatever deno offers from the command line. For example, you can run deno's repl (with elisp functions) by running the following: emacs --batch --eval '(deno \"repl\")' You can use deno's formatter by running emacs --batch --eval '(deno \"fmt\")' You could even run a script via emacs --batch --eval '(deno \"run\" \"--allow-read\" \"test.ts\")' Note you need to specify read/write/etc. permissions. Think of this as if you were using emacs AS deno. The deno function takes the exact same flags as the deno application. It's designed for use in batch mode on the command line, however it can also be used in regular elisp. Where to go next # We don't want to duplicate Deno's excellent documentation, so it's recommended you read their manual for their standard library, and their examples.","title":"Using Deno"},{"location":"using-deno/#using-the-power-of-deno","text":"","title":"Using the power of Deno"},{"location":"using-deno/#what-is-deno","text":"Deno is a program that is similar to node.js, except it is written in Rust. Both Deno and nodejs were created by the same person, Ryan Dhal. While normally you would invoke Deno via the command line, the emacs-ng project has integrated the Deno runtime into the emacs-ng client directly. Deno is powered by v8, Chrome's Open Source JavaScript engine. A JavaScript engine is more limited then most users realize. For example, utilities like XMLHttpRequest are not provided directly by the JavaScript engine, but are instead provided by a runtime (like your browser). Deno provides interfaces for performing I/O operations like file reads/writes, network operations, and spawning subprocesses. By default, emacs-ng will allow reading, writing, network, and subprocess operations. In Deno's examples, you may see them advise you to pass flags like \"--allow-net\". These are not needed when executing emacs-ng code. If you want to globally disable any of the previously mentioned operations, you can run the following lisp prior to executing JavaScript: (js-initialize :allow-net nil :allow-read nil :allow-write nil :allow-run nil) You can define any combination of the above arguments. See js-initialize's documentation for more information.","title":"What is Deno ?"},{"location":"using-deno/#general-documentation-standard-library","text":"Deno has excellent documentation . This guide is to give you a basic familiarity with Deno to allow you to quickly write applications, but is FAR from all inclusive. Deno maintains a powerful standard library at https://deno.land/std@0.83.0 . Importing a deno std module is simple: just include this in your JavaScript file/buffer: Credit to https://deno.land/std@0.83.0/fs for the example: import { copy , copySync } from \"https://deno.land/std@0.83.0/fs/mod.ts\" ; copy ( \"./foo\" , \"./bar\" ); // returns a promise copySync ( \"./foo\" , \"./bar\" ); // void copySync ( \"./foo\" , \"./existingFolder\" , { overwrite : true }); The first thing you may notice is that we are importing a URL, not a local filepath. Deno allows you to download dependencies from the network. This file will only be downloaded once and compiled once, and it's results will be cached on your local file system. After initial download, you will use your local filesystem's copy instead of using the network. By default, all Deno API's are asynchronous . Almost all async operations have an alternate version that is synchronous. That means that when you make a call to read a file, or walk a directory, it is returning a Promise. Deno has the naming convention that the synchronous versions all end in \" Sync\". A common point of confusion with emacs-ng is that when you evaluate a file, a buffer, or even an anonymous block in JavaScript via (eval-js) , you are executing your code within a JavaScript module with toplevel await enabled. What does that mean? If you invoke await within your toplevel module, you will block the main thread until completion. Looking again with our example above with that in mind: import { copy } from \"https://deno.land/std@0.83.0/fs/mod.ts\" ; // This block the main thread, including lisp execution, until this action is completed await copy ( \"./foo\" , \"./bar\" ); // This does not block JavaScript or Lisp, instead our .then will be executed once // the async action is complete. copy ( \"./foo\" , \"./bar\" ). then (() => console . log ( \"Complete\" )); Remember that async/await in JavaScript is just syntax sugar over Promises. There may be times where you want to use the toplevel await functionality to block on a promise at a certain time.","title":"General Documentation / Standard Library"},{"location":"using-deno/#distribution","text":"Once you have created your great emacs-ng module, how do you distribute it? Normally you would go through a repository like ELPA or MELPLA. While that is still a possibility, you have a third option, which is Deno's user modules . Navigating to the link below gives you the information on the upload process, but in the author's opinion, it is very simple and streamlined. Once your module is uploaded, you can have your user's include a line similar to this in their init.el (eval-js \"import 'https://deno.land/x/fuzzy_search@0.3.0/mod-fuzzy.js'\") Where instead of fuzzy_search@0.3.0/mod-fuzzy.js, you instead have your module version and filename.","title":"Distribution"},{"location":"using-deno/#using-emacs-as-deno","text":"emacs-ng offers the deno function in elisp, which allows users to leverage whatever deno offers from the command line. For example, you can run deno's repl (with elisp functions) by running the following: emacs --batch --eval '(deno \"repl\")' You can use deno's formatter by running emacs --batch --eval '(deno \"fmt\")' You could even run a script via emacs --batch --eval '(deno \"run\" \"--allow-read\" \"test.ts\")' Note you need to specify read/write/etc. permissions. Think of this as if you were using emacs AS deno. The deno function takes the exact same flags as the deno application. It's designed for use in batch mode on the command line, however it can also be used in regular elisp.","title":"Using emacs as deno"},{"location":"using-deno/#where-to-go-next","text":"We don't want to duplicate Deno's excellent documentation, so it's recommended you read their manual for their standard library, and their examples.","title":"Where to go next"}]}